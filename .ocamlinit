#directory "/Users/jrrk/.opam/default/lib/xml-light";;
#print_depth 100000;;
#print_length 1000000;;

open Vxml
open Template_ilang

let xmlf = "obj_dir/Vtimer.xml";;

let errlst = ref [];;
let (line,range,rwxml,xml,mods,toplst,topattr) = Vxml.translate errlst xmlf;;

let f k = Hashtbl.find Vxml.modules k;;
let p k = Hashtbl.find Vxml.packages k;;
let d f = Vxml.debug f (Hashtbl.find Vxml.modules f)
let h k = Hashtbl.find Vxml.hierarchy k;;

let othcnt = (
List.length !exprothlst,
List.length !stmtothlst,
List.length !portothlst,
List.length !iothlst,
List.length !csothlst,
List.length !bgnothlst,
List.length !itmothlst,
List.length !catothlst,
List.length !cellothlst,
List.length !posneglst,
List.length !typothlst,
List.length !memothlst
);;

let dumps s = "\""^s^"\""
let dumpstrlst lst = "["^String.concat ";\n\t" (List.map dumps lst)^"]"

let rec dumpdir = function
| Dinput -> "input"
| Doutput -> "output"
| Dinout -> "inout"
| Dvif s -> "Dvif "^dumps !s
| Dinam str -> "Dinam "^dumps str
| Dport(str1, int1, dirop, str2, str_lst) ->
     "Dport("^dumps str1 ^", "^ string_of_int int1 ^", "^ dumpdir dirop ^", "^ dumps str2 ^", "^ dumpstrlst str_lst^")"
| Dunknown -> "Dunknown"

let wref = ref [];;
let err = ref "";;
let then' = ref UNKNOWN;;
let else' = ref UNKNOWN;;
let op' = ref Aunknown;;
let ops' = ref (UNKNOWN,UNKNOWN);;

let flt' oth = String.concat ":" (List.map (tokencnv (ref 0)) oth);;
let _ = Hashtbl.iter (fun k (_,modul) -> 
let iolst = List.map (fun (io, (origin, typ', dir, kind', lst)) -> 
    (io,dumpdir dir,findmembers' typ')
    ) !(modul.io) in
let wlst = iolst @ List.map (fun (id, (origin, typ', kind', n)) ->
    (id,"width",findmembers' typ')) !(modul.v) in
wref := wlst;
let wlst' = List.map (fun (id, dir, (rng,_,_)) -> match rng with 
| BIT :: [] -> (1, dir, id)
| ARNG(hi,lo) :: [] -> (hi-lo+1, dir, id)
| oth -> err := flt' (comment oth); failwith "rng"
) wlst in
let cellst' = ref [] in
let proclst' = List.map (function 
| (_, POSPOS (ck, rst), lst) -> (match lst with
  | IF(_, cnd :: then_stmt :: else_stmt :: []) :: [] ->
    (match then_stmt with
      | BGN(None, lst) -> (match lst with
        | ASGN(_, _, lft :: rght :: []) :: [] -> ()
	| oth -> then' := List.hd oth; failwith "then");
      | oth -> then' := oth; failwith "then");
    (match else_stmt with
      | BGN(None, lst) -> (match lst with
        | ASGN(_, _, lft :: rght :: []) :: [] -> (match lft with
	  | ARITH(_, op, lft' :: rght' :: []) -> (match op with
	    | Asub -> ops' := (lft',rght');
let arg1 = match lft' with VRF(arg, (BASDTYP, "logic", TYPRNG (HEX 4, HEX 0), []), []) -> arg in
let arg2 = match rght' with CNST (w, HEX n) -> string_of_int n | _ -> "" in
let params = ("A_SIGNED", 0) :: ("A_WIDTH", 5) ::
 ("B_SIGNED", 0) :: ("B_WIDTH", 32) ::
("Y_WIDTH", 32) :: [] in
let connects = ("A", arg1) :: ("B", arg2) :: ("Y", "$Y") :: [] in
 cellst' := ("sub","sub2", params, connects) :: !cellst'
	    | oth -> op' := oth; failwith "op")
	  | oth -> then' := oth; failwith "lft")
	| oth -> then' := List.hd oth; failwith "else");
      | oth -> else' := oth; failwith "else");
 "arg1","arg2","arg3"
  | oth -> failwith "if")
| oth -> failwith "sentry") !(modul.alwys) in
let asgnlst' = List.map (function
| (_, VRF(dst, typ, []), e) -> dst,flt'(expr modul e)
| oth -> failwith "assign") !(modul.ca) in
template_ilang stdout "timer" wlst' !cellst' proclst' asgnlst') Vxml.modules;;

